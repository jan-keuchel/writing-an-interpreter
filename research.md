# Information necessary in order to write a compiler

## Pieces of a compiler
- Lexer
- Parser
- AST
- Bytecode-compiler
- Bytecode interpreter
- Runtime


## Language example

```
int a = 3;
if (a <= 5) {
    print("a is small");
} else {
    print(a);
}
for (a <= 5) {
    a = a + 1;
}

func add(int x, int y) int {
    return x + y;
}
```

### Requirements of the language to build
#### Data types
- integer
- float
- string
- boolean

#### Structures
- arrays

#### Flow control
- functions
- if/else statements
- loops

## How the compiler works
Lexing, Parsing and building of the AST all happen at static time, meaning the programm is not running so far. It's just a translation from one representation to another.

### Lexer 
- Aka **tokenizer**. Turns an input into Tokens. 
- Tokens are the names of things that appear in the programm and their corresponding values. (NAME, EQUAL, SEMILCOLON, IF, FOR, PRINT, LBRACE, RBRACE...). Basically, *Type:Value* pairs.
- Everything becomes a token except for whitespace
- Tokenizer has a *next* function that spits out the next Token it read.
- The Lexer does **not** check for syntactically correct programms!

### Parser
- Takes tokens as a input and tries to figure out the structure of the original program. Conversion into an **Abstract Syntax Tree** (AST)
- Check for syntactically correct programm.
- Has building *blocks* (If, Assignment, Comparison, Equals, Number) and chains them together, thus creating the structure of the programm.
- Can be written by hand (*Hand-written parsers*) or generated by another programm (*Automatically generated parsers*)

### AST
- Representation of the input programm that is suitable for a machine.
